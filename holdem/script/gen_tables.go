package main

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"sort"
)

// Cactus Kev prime list: rank index 0..12 maps to 2..A.
var primes = [...]int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41}

type hand struct {
	ranksAsc [5]int // 0..12 ascending
	bitmask  int
}

func main() {
	unique5, flushes, products := buildTables()
	scriptDir := filepath.Dir(currentFile())
	writeGoFile(filepath.Join(scriptDir, "..", "tables.go"), unique5, flushes, products)
}

func currentFile() string {
	_, file, _, ok := runtime.Caller(0)
	if !ok {
		panic("cannot resolve script file path")
	}
	return file
}

func buildTables() (map[int]int, map[int]int, map[int]int) {
	unique5 := make(map[int]int, 1287)
	flushes := make(map[int]int, 1287)
	products := make(map[int]int, 4888)

	hands := make([]hand, 0, 1287)
	for a := 0; a < 13; a++ {
		for b := a + 1; b < 13; b++ {
			for c := b + 1; c < 13; c++ {
				for d := c + 1; d < 13; d++ {
					for e := d + 1; e < 13; e++ {
						ranks := [5]int{a, b, c, d, e}
						mask := (1 << a) | (1 << b) | (1 << c) | (1 << d) | (1 << e)
						hands = append(hands, hand{ranksAsc: ranks, bitmask: mask})
					}
				}
			}
		}
	}

	straightHands := make([]hand, 0, 10)
	nonStraightHands := make([]hand, 0, 1277)
	for _, h := range hands {
		if isStraight(h.ranksAsc) {
			straightHands = append(straightHands, h)
		} else {
			nonStraightHands = append(nonStraightHands, h)
		}
	}

	// Straight strength order: A-high .. 5-high wheel.
	sort.Slice(straightHands, func(i, j int) bool {
		return straightHigh(straightHands[i].ranksAsc) > straightHigh(straightHands[j].ranksAsc)
	})

	// Lexicographic rank-desc for non-straight unique rank hands.
	sort.Slice(nonStraightHands, func(i, j int) bool {
		for k := 4; k >= 0; k-- {
			if nonStraightHands[i].ranksAsc[k] != nonStraightHands[j].ranksAsc[k] {
				return nonStraightHands[i].ranksAsc[k] > nonStraightHands[j].ranksAsc[k]
			}
		}
		return false
	})

	// Flushes table.
	vStraightFlush := 1 // 1..10
	for _, h := range straightHands {
		flushes[h.bitmask] = vStraightFlush
		vStraightFlush++
	}
	vFlush := 323 // 323..1599
	for _, h := range nonStraightHands {
		flushes[h.bitmask] = vFlush
		vFlush++
	}

	// Unique5 table.
	vStraight := 1600 // 1600..1609
	for _, h := range straightHands {
		unique5[h.bitmask] = vStraight
		vStraight++
	}
	vHighCard := 6186 // 6186..7462
	for _, h := range nonStraightHands {
		unique5[h.bitmask] = vHighCard
		vHighCard++
	}

	primeProduct := func(indices ...int) int {
		p := 1
		for _, idx := range indices {
			p *= primes[idx]
		}
		return p
	}

	// Four of a kind: 11..166
	val := 11
	for i := 12; i >= 0; i-- {
		for j := 12; j >= 0; j-- {
			if i == j {
				continue
			}
			products[primeProduct(i, i, i, i, j)] = val
			val++
		}
	}

	// Full house: 167..322
	val = 167
	for i := 12; i >= 0; i-- {
		for j := 12; j >= 0; j-- {
			if i == j {
				continue
			}
			products[primeProduct(i, i, i, j, j)] = val
			val++
		}
	}

	// Three of a kind: 1610..2467
	val = 1610
	for i := 12; i >= 0; i-- {
		for j := 12; j >= 0; j-- {
			for k := j - 1; k >= 0; k-- {
				if i == j || i == k {
					continue
				}
				products[primeProduct(i, i, i, j, k)] = val
				val++
			}
		}
	}

	// Two pair: 2468..3325
	val = 2468
	for i := 12; i >= 0; i-- {
		for j := i - 1; j >= 0; j-- {
			for k := 12; k >= 0; k-- {
				if k == i || k == j {
					continue
				}
				products[primeProduct(i, i, j, j, k)] = val
				val++
			}
		}
	}

	// One pair: 3326..6185
	val = 3326
	for i := 12; i >= 0; i-- {
		for j := 12; j >= 0; j-- {
			for k := j - 1; k >= 0; k-- {
				for l := k - 1; l >= 0; l-- {
					if i == j || i == k || i == l {
						continue
					}
					products[primeProduct(i, i, j, k, l)] = val
					val++
				}
			}
		}
	}

	return unique5, flushes, products
}

func isStraight(r [5]int) bool {
	// Wheel: A2345 => [0,1,2,3,12]
	if r[0] == 0 && r[1] == 1 && r[2] == 2 && r[3] == 3 && r[4] == 12 {
		return true
	}
	for i := 0; i < 4; i++ {
		if r[i]+1 != r[i+1] {
			return false
		}
	}
	return true
}

func straightHigh(r [5]int) int {
	if r[0] == 0 && r[1] == 1 && r[2] == 2 && r[3] == 3 && r[4] == 12 {
		return 5
	}
	if r[4] == 12 {
		return 14
	}
	return r[4] + 2
}

func writeGoFile(outputPath string, unique5, flushes, products map[int]int) {
	f, err := os.Create(outputPath)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintln(f, "package holdem")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "// Code generated by script/gen_tables.go; DO NOT EDIT.")
	fmt.Fprintln(f)

	writeMap(f, "kevUnique5Table", unique5)
	writeMap(f, "kevFlushesTable", flushes)
	writeMap(f, "kevProductsTable", products)
}

func writeMap(f *os.File, name string, m map[int]int) {
	fmt.Fprintf(f, "var %s = map[int]int{\n", name)
	keys := make([]int, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Ints(keys)
	for _, k := range keys {
		fmt.Fprintf(f, "\t%d: %d,\n", k, m[k])
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)
}
